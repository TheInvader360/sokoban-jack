class View {
    field Model model;

    constructor View new(Model aModel) {
        let model = aModel;
        return this;
    }

    method void draw() {
        var int x, y;
        var Board board;
        var Player player;

        let board = model.getBoard();
        let player = board.getPlayer();

        // not very mvc, but the more usual "fully clear and redraw the screen on each frame" approach doesn't really suit the hack platform... 
        if (model.isScreenDirty()) {
            do Screen.setColor(false);
            do Screen.drawRectangle(0, 0, 511, 255);
        }

        // draw some test sprites
        let x = 24;
        let y = 11;
        while (y < 15) {
            while (x < 31) {
                if ((x > 10) | (x < 31) | (y > 10) | (y < 15)) {
                    if (model.getTickAccumulator() < 2) {
                        do Sprites.drawBox(x + (y * 512));
                    }
                    else {
                        if (model.getTickAccumulator() < 4) {
                            do Sprites.drawGoal(x + (y * 512));
                        }
                        else {
                            if (model.getTickAccumulator() < 6) {
                                do Sprites.drawGoalBox(x + (y * 512));
                            }
                            else {
                                if (model.getTickAccumulator() < 8) {
                                    do Sprites.drawGoalPlayer(x + (y * 512));
                                }
                                else {
                                    if (model.getTickAccumulator() < 10) {
                                        do Sprites.drawPlayer(x + (y * 512));
                                    }
                                    else {
                                        if (model.getTickAccumulator() < 12) {
                                            do Sprites.drawWall(x + (y * 512));
                                        }
                                        else {
                                            if ((x = player.getX()) & (y = player.getY())) {
                                                //draw the player
                                                do Sprites.drawPlayer(player.getX() + (player.getY() * 512));
                                            }
                                            else {
                                                do Sprites.drawClear(x + (y * 512));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                let x = x + 1;
            }
            let y = y + 1;
            let x = 24;
        }

        // clear part of the screen
        do Screen.setColor(false);
        do Screen.drawRectangle(0, 243, 15, 253);

        // draw the tick accumulator's current value
        do Screen.setColor(true);
        do Output.moveCursor(22, 0);
        do Output.printInt(model.getTickAccumulator());

        // draw the board
        do drawBoard();

        return;
    }

    method void drawBoard() {
        //TODO: game state dependent drawing...

        var Board board;
        var int x, y, width, height, boardOffsetX, boardOffsetY;
        var Player player;
        var Cell cell;

        let board = model.getBoard();
        let x = 0;
        let y = 0;
        let width = board.getWidth();
        let height = board.getHeight();
        let boardOffsetX = ((22 - width) / 2) + 1;
		let boardOffsetY = ((14 - height) / 2) + 1;
        let player = board.getPlayer();

        while (y < height) {
            while (x < width) {
                let cell = board.getCell(x, y);
                if ((player.getX() = x) & (player.getY() = y)) {
                    if (cell.getTypeOf() = CellType.CellTypeGoal()) {
                        do Sprites.drawGoalPlayer(boardOffsetX + x + ((boardOffsetY + y) * 512));
                    }
                    else {
                        do Sprites.drawPlayer(boardOffsetX + x + ((boardOffsetY + y) * 512));
                    }
                }
                else {
                    if (cell.getTypeOf() = CellType.CellTypeNone()) {
                        if (cell.getHasBox()) {
                            do Sprites.drawBox(boardOffsetX + x + ((boardOffsetY + y) * 512));
                        }
                        else {
                            do Sprites.drawClear(boardOffsetX + x + ((boardOffsetY + y) * 512));
                        }
                    }
                    if (cell.getTypeOf() = CellType.CellTypeGoal()) {
                        if (cell.getHasBox()) {
                            do Sprites.drawGoalBox(boardOffsetX + x + ((boardOffsetY + y) * 512));
                        }
                        else {
                            do Sprites.drawGoal(boardOffsetX + x + ((boardOffsetY + y) * 512));
                        }
                    }
                    if (cell.getTypeOf() = CellType.CellTypeWall()) {
                        do Sprites.drawWall(boardOffsetX + x + ((boardOffsetY + y) * 512));
                    }
                }
                let x = x + 1;
            }
            let y = y + 1;
            let x = 0;
        }

        return;
    }

    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }
}
